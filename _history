{"entries":[{"timestamp":1744705766188,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n"],[0,"</xm"]],"start1":12,"start2":12,"length1":70,"length2":113}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n"],[-1,"/**\n * Namespace pour le contrôle du déplacement d'un robot microbit\n * Utilise l'odométrie et les encodeurs magnétiques pour le positionnement précis\n * Avec support de différents drivers moteurs via des callbacks\n */\n//% color=\"#00A1E9\" weight=100 icon=\"\\uf1b9\" block=\"RobotMovement\"\nnamespace RobotMovement {\n    // Définition des types pour les callbacks\n    export type MotorDriverFunction = (leftSpeed: number, rightSpeed: number, leftDirection: Direction, rightDirection: Direction) => void;\n    export type EncoderReaderFunction = () => { leftDelta: number, rightDelta: number };\n\n    // Enum pour la direction des moteurs\n    export enum Direction {\n        //% block=\"Avant (CW)\"\n        Forward = 0,\n        //% block=\"Arrière (CCW)\"\n        Backward = 1\n    }\n\n    // Variables pour les moteurs et encodeurs\n    let isInitialized = false;\n    let baseSpeed = 50; // Vitesse de base des moteurs (0-100)\n\n    // Callbacks pour les fonctions adaptables\n    let motorDriverCallback: MotorDriverFunction = null;\n    let encoderReaderCallback: EncoderReaderFunction = null;\n\n    // Constantes PID\n    const Kp = 0.5;    // Coefficient proportionnel\n    const Ki = 0.05;   // Coefficient intégral\n    const Kd = 0.2;    // Coefficient dérivé\n\n    // Variables pour garder une trace de l'erreur précédente et de l'erreur cumulée\n    let previousError = 0;\n    let integralError = 0;\n\n    // Timeout pour les mouvements (ms)\n    const MOVEMENT_TIMEOUT = 10000;\n\n    /**\n     * Définit le gestionnaire de moteur pour les moteurs standard\n     * @param pin1 Pin moteur gauche\n     * @param pin2 Pin moteur droit\n     */\n    //% blockId=robotmovement_set_standard_motors\n    //% block=\"Utiliser moteurs standard sur pins %pin1 et %pin2\"\n    //% pin1.defl=0 pin2.defl=1\n    //% weight=100\n    /*\n    export function setStandardMotors(pin1: number, pin2: number): void {\n        initialize(\n            // Callback pour les moteurs\n            (leftSpeed, rightSpeed, leftDir, rightDir) => {\n                // Pour les moteurs utilisant la librairie \"motor\"\n                const leftDirMap = leftDir === Direction.Forward ? motor.Dir.CW : motor.Dir.CCW;\n                const rightDirMap = rightDir === Direction.Forward ? motor.Dir.CW : motor.Dir.CCW;\n                motor.motorRun(pin1, leftDirMap, leftSpeed);\n                motor.motorRun(pin2, rightDirMap, rightSpeed);\n            },\n            // Callback pour les encodeurs\n            () => {\n                // Exemple avec les encodeurs magnétiques\n                encoders.getValues();\n                return {\n                    leftDelta: encoders.getDeltaLeftValue(),\n                    rightDelta: encoders.getDeltaRightValue()\n                };\n            }\n        );\n    }*/\n\n    /**\n     * Définit le gestionnaire de moteur pour les servomoteurs continus\n     * @param pinLeft Pin servo moteur gauche\n     * @param pinRight Pin servo moteur droit\n     */\n    //% blockId=robotmovement_set_servos\n    //% block=\"Utiliser servomoteurs continus sur pins %pinLeft et %pinRight\"\n    //% pinLeft.defl=AnalogPin.P1 pinRight.defl=AnalogPin.P2\n    //% weight=90\n    /*\n    export function setContinuousServos(pinLeft: AnalogPin, pinRight: AnalogPin): void {\n        initialize(\n            // Callback pour les servomoteurs\n            (leftSpeed, rightSpeed, leftDir, rightDir) => {\n                // Pour des servomoteurs continus:\n                // - La valeur 90 correspond à l'arrêt\n                // - Les valeurs 0-89 => rotation dans un sens\n                // - Les valeurs 91-180 => rotation dans l'autre sens\n\n                let leftValue = 90;  // Valeur par défaut = arrêt\n                let rightValue = 90; // Valeur par défaut = arrêt\n\n                if (leftSpeed > 0) {\n                    if (leftDir === Direction.Forward) {\n                        leftValue = 90 - Math.map(leftSpeed, 0, 100, 0, 90);\n                    } else {\n                        leftValue = 90 + Math.map(leftSpeed, 0, 100, 0, 90);\n                    }\n                }\n\n                if (rightSpeed > 0) {\n                    if (rightDir === Direction.Forward) {\n                        rightValue = 90 + Math.map(rightSpeed, 0, 100, 0, 90);\n                    } else {\n                        rightValue = 90 - Math.map(rightSpeed, 0, 100, 0, 90);\n                    }\n                }\n\n                // Limiter les valeurs dans la plage 0-180\n                leftValue = Math.constrain(leftValue, 0, 180);\n                rightValue = Math.constrain(rightValue, 0, 180);\n\n                // Envoyer les commandes aux servomoteurs\n                pins.servoWritePin(pinLeft, leftValue);\n                pins.servoWritePin(pinRight, rightValue);\n\n                // Afficher les valeurs pour débogage (optionnel)\n                serial.writeString(\"Servo G: \" + leftValue + \" D: \" + rightValue + \"\\n\");\n            },\n\n            // Callback pour les encodeurs (exemple avec AS5048B)\n            () => {\n                ams_AS5048B.update();\n                return {\n                    leftDelta: ams_AS5048B.getDeltaLeftTicks(),\n                    rightDelta: ams_AS5048B.getDeltaRightTicks()\n                };\n            }\n        );\n    }*/\n\n    /**\n     * Définit des gestionnaires personnalisés pour les moteurs et encodeurs\n     * @param onMotorControl Fonction de contrôle des moteurs\n     * @param onEncoderRead Fonction de lecture des encodeurs\n     */\n    //% blockId=robotmovement_set_custom_handlers\n    //% block=\"Définir gestionnaires personnalisés\"\n    //% draggableParameters=\"reporter\"\n    //% weight=80\n    export function setCustomHandlers(\n        onMotorControl: (leftSpeed: number, rightSpeed: number, leftDir: Direction, rightDir: Direction) => void,\n        onEncoderRead: () => { leftDelta: number, rightDelta: number }\n    ): void {\n        initialize(onMotorControl, onEncoderRead);\n    }\n\n    /**\n     * Initialise le système de déplacement avec des callbacks adaptables\n     * @param motorDriver Fonction pour contrôler les moteurs\n     * @param encoderReader Fonction pour lire les valeurs des encodeurs\n     */\n    function initialize(motorDriver: MotorDriverFunction, encoderReader: EncoderReaderFunction): void {\n        motorDriverCallback = motorDriver;\n        encoderReaderCallback = encoderReader;\n        isInitialized = true;\n\n        // Vérification de l'initialisation\n        if (motorDriverCallback && encoderReaderCallback) {\n            basic.showIcon(IconNames.Yes);\n            serial.writeLine(\"Système de déplacement initialisé\");\n        } else {\n            basic.showIcon(IconNames.No);\n            serial.writeLine(\"Erreur: callbacks non définis\");\n            isInitialized = false;\n        }\n    }\n\n    /**\n     * Définit la vitesse de base des moteurs\n     * @param speed Vitesse entre 0 et 100\n     */\n    //% blockId=robotmovement_set_base_speed\n    //% block=\"Régler vitesse de base à %speed\"\n    //% speed.min=0 speed.max=100 speed.defl=50\n    //% weight=70\n    export function setBaseSpeed(speed: number): void {\n        baseSpeed = Math.constrain(speed, 0, 100);\n    }\n\n    /**\n     * Applique les commandes de moteur en utilisant le callback défini\n     * @param leftSpeed Vitesse du moteur gauche (0-100)\n     * @param rightSpeed Vitesse du moteur droit (0-100)\n     * @param leftDir Direction du moteur gauche\n     * @param rightDir Direction du moteur droit\n     */\n    function applyMotorCommand(leftSpeed: number, rightSpeed: number, leftDir: Direction, rightDir: Direction): void {\n        if (motorDriverCallback) {\n            // Limiter les vitesses entre 0 et 100\n            leftSpeed = Math.constrain(leftSpeed, 0, 100);\n            rightSpeed = Math.constrain(rightSpeed, 0, 100);\n\n            // Appeler le callback moteur\n            motorDriverCallback(leftSpeed, rightSpeed, leftDir, rightDir);\n        }\n    }\n\n    /**\n     * Lit les valeurs des encodeurs en utilisant le callback défini\n     * @returns Objet contenant les deltas des encodeurs gauche et droit\n     */\n    function readEncoders(): { leftDelta: number, rightDelta: number } {\n        if (encoderReaderCallback) {\n            return encoderReaderCallback();\n        }\n        return { leftDelta: 0, rightDelta: 0 };\n    }\n\n    /**\n     * Arrête les moteurs\n     */\n    //% blockId=robotmovement_stop_motors\n    //% block=\"Arrêter les moteurs\"\n    //% weight=60\n    export function stopMotors(): void {\n        if (motorDriverCallback) {\n            motorDriverCallback(0, 0, Direction.Forward, Direction.Forward);\n        }\n    }\n\n    /**\n     * Déplace le robot vers une position relative (x,y) en mm\n     * @param distX distance à parcourir en x (mm)\n     * @param distY distance à parcourir en y (mm)\n     */\n    //% blockId=robotmovement_movexy\n    //% block=\"Déplacer de X:%distX mm Y:%distY mm\"\n    //% distX.defl=100 distY.defl=0\n    //% weight=50\n    export function movexy(distX: number, distY: number): void {\n        if (!isInitialized) {\n            serial.writeLine(\"Erreur: système de déplacement non initialisé\");\n            return;\n        }\n\n        // Calcul de la distance totale à parcourir\n        const distance = Math.sqrt(distX * distX + distY * distY);\n\n        // Calcul de l'angle cible en radians\n        let targetAngle = Math.atan2(distY, distX);\n\n        // Angle de rotation nécessaire (différence entre l'angle cible et l'angle actuel)\n        let angleDiff = targetAngle - odometry.getOrientationRad();\n\n        // Normalisation entre -π et π\n        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;\n        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;\n\n        // Conversion en degrés pour la fonction turn\n        let angleDiffDeg = angleDiff * 180 / Math.PI;\n\n        // 1. Tourner vers la direction cible\n        turn(angleDiffDeg);\n\n        // 2. Avancer de la distance calculée\n        moveForward(distance);\n    }\n\n    /**\n     * Tourne le robot d'un angle spécifié en degrés\n     * @param angleDegrees angle de rotation en degrés (positif = sens anti-horaire)\n     */\n    //% blockId=robotmovement_turn\n    //% block=\"Tourner de %angleDegrees degrés\"\n    //% angleDegrees.min=-180 angleDegrees.max=180 angleDegrees.defl=90\n    //% weight=40\n    export function turn(angleDegrees: number): void {\n        if (!isInitialized) {\n            serial.writeLine(\"Erreur: système de déplacement non initialisé\");\n            return;\n        }\n\n        // Normaliser l'angle entre -180 et 180 degrés pour prendre le chemin le plus court\n        while (angleDegrees > 180) angleDegrees -= 360;\n        while (angleDegrees < -180) angleDegrees += 360;\n\n        // Convertir en radians\n        const angleRadians = angleDegrees * Math.PI / 180;\n\n        // Position cible\n        const targetOrientation = odometry.getOrientationRad() + angleRadians;\n\n        // Réinitialiser les erreurs PID\n        previousError = 0;\n        integralError = 0;\n\n        // Démarrer les moteurs dans la bonne direction\n        if (angleDegrees > 0) {\n            // Tourner à gauche (sens anti-horaire)\n            applyMotorCommand(baseSpeed, baseSpeed, Direction.Backward, Direction.Forward);\n        } else {\n            // Tourner à droite (sens horaire)\n            applyMotorCommand(baseSpeed, baseSpeed, Direction.Forward, Direction.Backward);\n        }\n\n        // Durée maximale pour éviter une boucle infinie\n        const startTime = input.runningTime();\n\n        // Boucle jusqu'à atteindre l'orientation cible\n        while (true) {\n            // Mettre à jour l'odométrie\n            const encoderData = readEncoders();\n            odometry.updateFromTicks(encoderData.leftDelta, encoderData.rightDelta);\n\n            // Calculer l'erreur actuelle (différence entre l'orientation cible et l'orientation actuelle)\n            let currentOrientation = odometry.getOrientationRad();\n            let error = angleBetween(targetOrientation, currentOrientation);\n\n            // Vérifier si l'objectif est atteint\n            if (Math.abs(error) < 0.03) { // ~1.7 degrés de précision\n                break;\n            }\n\n            // Calculer les composantes PID\n            let proportional = error * Kp;\n            integralError += error;\n            let integral = integralError * Ki;\n            let derivative = (error - previousError) * Kd;\n            previousError = error;\n\n            // Calculer la correction de la vitesse\n            let correction = proportional + integral + derivative;\n\n            // Appliquer la correction aux moteurs\n            let leftSpeed = baseSpeed + correction;\n            let rightSpeed = baseSpeed - correction;\n\n            // Limiter les vitesses\n            leftSpeed = Math.constrain(leftSpeed, 0, 100);\n            rightSpeed = Math.constrain(rightSpeed, 0, 100);\n\n            // Actualiser les vitesses des moteurs\n            if (angleDegrees > 0) {\n                // Tourner à gauche\n                applyMotorCommand(leftSpeed, rightSpeed, Direction.Backward, Direction.Forward);\n            } else {\n                // Tourner à droite\n                applyMotorCommand(leftSpeed, rightSpeed, Direction.Forward, Direction.Backward);\n            }\n\n            // Vérifier le timeout\n            if (input.runningTime() - startTime > MOVEMENT_TIMEOUT) {\n                serial.writeLine(\"Timeout de rotation\");\n                break;\n            }\n\n            // Petit délai pour éviter une utilisation trop intensive du processeur\n            basic.pause(10);\n        }\n\n        // Arrêter les moteurs\n        stopMotors();\n    }\n\n    /**\n     * Déplace le robot vers l'avant d'une distance spécifiée en mm\n     * @param distance distance à parcourir en mm\n     */\n    //% blockId=robotmovement_move_forward\n    //% block=\"Avancer de %distance mm\"\n    //% distance.defl=100 distance.min=0\n    //% weight=30\n    export function moveForward(distance: number): void {\n        if (!isInitialized) {\n            serial.writeLine(\"Erreur: système de déplacement non initialisé\");\n            return;\n        }\n\n        // Calculer la position cible\n        const startX = odometry.getX();\n        const startY = odometry.getY();\n        const angle = odometry.getOrientationRad();\n        const targetX = startX + Math.cos(angle) * distance;\n        const targetY = startY + Math.sin(angle) * distance;\n\n        // Réinitialiser les erreurs PID\n        previousError = 0;\n        integralError = 0;\n\n        // Démarrer les moteurs en marche avant\n        applyMotorCommand(baseSpeed, baseSpeed, Direction.Forward, Direction.Forward);\n\n        // Durée maximale pour éviter une boucle infinie\n        const startTime = input.runningTime();\n\n        // Boucle jusqu'à atteindre la position cible\n        while (true) {\n            // Mettre à jour l'odométrie\n            const encoderData = readEncoders();\n            odometry.updateFromTicks(encoderData.leftDelta, encoderData.rightDelta);\n\n            // Calculer l'erreur de distance restante\n            const distanceRemaining = odometry.distanceTo(targetX, targetY);\n\n            // Calculer l'erreur d'orientation (pour rester en ligne droite)\n            const currentAngle = odometry.getOrientationRad();\n            const angleError = angleBetween(angle, currentAngle);\n\n            // Vérifier si l'objectif est atteint\n            if (distanceRemaining < 5) { // 5mm de précision\n                break;\n            }\n\n            // Calculer la correction d'orientation par PID\n            let proportional = angleError * Kp;\n            integralError += angleError;\n            let integral = integralError * Ki;\n            let derivative = (angleError - previousError) * Kd;\n            previousError = angleError;\n\n            // Calculer la correction de la vitesse pour maintenir la trajectoire\n            let correction = proportional + integral + derivative;\n\n            // Appliquer la correction aux moteurs\n            let leftSpeed = baseSpeed - correction;\n            let rightSpeed = baseSpeed + correction;\n\n            // Ajuster la vitesse globale en fonction de la distance restante\n            let speedMultiplier = 1.0;\n            if (distanceRemaining < 100) {\n                speedMultiplier = distanceRemaining / 100;\n                speedMultiplier = Math.max(speedMultiplier, 0.3); // Au moins 30% de la vitesse\n            }\n\n            leftSpeed *= speedMultiplier;\n            rightSpeed *= speedMultiplier;\n\n            // Actualiser les vitesses des moteurs\n            applyMotorCommand(leftSpeed, rightSpeed, Direction.Forward, Direction.Forward);\n\n            // Vérifier le timeout\n            if (input.runningTime() - startTime > MOVEMENT_TIMEOUT) {\n                serial.writeLine(\"Timeout de déplacement\");\n                break;\n            }\n\n            // Petit délai pour éviter une utilisation trop intensive du processeur\n            basic.pause(10);\n        }\n\n        // Arrêter les moteurs\n        stopMotors();\n    }\n\n    /**\n     * Calcule la plus petite différence angulaire entre deux angles en radians\n     * @param angle1 Premier angle en radians\n     * @param angle2 Deuxième angle en radians\n     * @returns Différence d'angle normalisée entre -π et π\n     */\n    function angleBetween(angle1: number, angle2: number): number {\n        let diff = angle1 - angle2;\n\n        // Normaliser entre -π et π\n        while (diff > Math.PI) diff -= 2 * Math.PI;\n        while (diff < -Math.PI) diff += 2 * Math.PI;\n\n        return diff;\n    }\n\n}"]],"start1":0,"start2":0,"length1":17492,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"pxt-ams_as5048b\": \"workspace:bdc6fe26-67c0-4c9f-254e-e7de90379a32\""],[0,"\n"],[1,""],[0,"    "]],"start1":144,"start2":144,"length1":86,"length2":9},{"diffs":[[0,"   \""],[-1,"testFiles\": [\n        \"test.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":241,"start2":241,"length1":76,"length2":31}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1744705766187,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt-robotmovement\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1744706289843}